Tools
=====

This directory contains simple tools written in the AWK programming language
to help the simulation of the CPUs.

## FILES

* `tools/asm`:       LEGv8 assembler.
* `tools/tbgen`:     Testbench generator.


## THE ASSEMBLER

This assembler reads a file in LEGv8 assembly and creates two files.
One file contains the contents of the `.text` section of the source
file converted into machine language.  The other file contains the
contents of the `.data` section of the source file (ie' the contents
of the memory used for the program).

The assembler usage is described below.

	$ asm [-v VARIABLE:VALUE]... SOURCE

The options `-v VARIABLE:VALUE` sets a given variable to a given value.
Possible variables and their default values are the following.

* `databeg`: Number for the address, in bytes, whence the data memory begins (default: 0)
* `textsize`: Number for the size, in bits, of each instruction in the code memory (default: 32).

For example, the following command reads the source file `sumtwo.s` and
generates two files: `sumtwo.text` and `sumtwo.data`.

	$ cd ../samples
	$ ../tools/asm sumtwo.s

The following is the content of the source file `sumtwo.s`.
It defines two values into the beginning of the `.data` section of the memory;
and some instructions in the `.text` section.  This program gets the first two
values in the data memory and sum them writing the result into the register X0.

	.data
	a: .word 1
	b: .word 2
	
	.text
		// load a into X0
		LDA     X0, a
		LDUR    X0, [X0, #0]
	
		// load b into X1
		LDA     X1, b
		LDUR    X1, [X1, #0]
	
		// put a+b into X0
		ADD     X0, X0, X1

The following is the content of the output `sumtwo.data` file.
Each group of two characters is a byte of the memory in hexadecimal format.
Each line contains 8 bytes, that is, 64 bits.

	00 00 00 00 00 00 00 01
	00 00 00 00 00 00 00 02

And the following is the content of the output `sumtwo.text` file.
Again, each group of two characters is a byte; but each line contains
only 4 bytes, that is, 32 bits, which is the size of a LEGv8 instruction.
Note that there are more instructions in the output file than in the
source file.  That's because the source file contains the pseudo-instruction
`LDA`, which is replaced by four actual instructions.

	d2 80 00 00
	f2 a0 00 00
	f2 c0 00 00
	f2 e0 00 00
	f8 40 0c 00
	d2 80 01 01
	f2 a0 00 01
	f2 c0 00 01
	f2 e0 00 01
	f8 40 0c 21
	8b 01 00 00


## THE TESTBENCH GENERATOR

This command reads a verilog module (called device under test, or DUT)
and generates a testbench for it.  When compiled with iverilog(1) and
run with vvp(1), the testbench simulates the clock pulses and the reset
signals necessary to make the CPU run a given program, generating a
`testbench.vcd` file, which contains the waveforms of the simulation.
This file can be open with a waveform viewer program, like gtkwave(1).

The testbench can also creates the memory dump and register dump of the
CPU at the end of the simulation.  But for this to occur, we have to give
the testbench generator the correct arguments.

The usage of `tbgen` is illustrated below.
This reads the module in the file `SOURCE`,
and writes the testbench into the file `testbench.v`.

	$ tbgen [-v VARIABLE:VALUE]... [dump:MEMORY:FILE]... SOURCE >testbench.v

The `-v VARIABLE:VALUE` arguments sets a variable that affect the generation
of the testbench.  The following is a non-extensive list of supported variables
and their default values.

* `dumplevel`:  How many modules deep into the testbench should have the
                signals written into the waveform.  If this variable is 0,
                all modules have their signals written.  If this variable
                is 1, only the inputs generated by the testbench (the clock
                and the reset inputs) are written.  If this variable is 2,
                both the inputs generated by the testbench and the signals
                used by the device under test are written.  And so on.
                By default, its value is 1.
* `timescale`:  The time, in nanoseconds, that will be the unit of simulation.
                By default, its value is 1.
* `duration`:   The duration of the simulation in multiples of timescale
                By default, its value is 100.
* `step`:       The duration of the clock in multiples of timescale.
                By default, its value is 1.
* `incdir`:     Directory used to search for included files.

The `dump:MEMORY:FILE` argument makes the simulation writes a system dump,
that is, write the content of the MEMORY into FILE, at the end of simulation.

For testing the CPUs, we set `dumplevel` to 3, so we can see in the waveforms
the inputs generated by the testbench, the signals of the datapath, and the
signals of the modules used by the datapath.  We also must include the header
files at `../include/`.

While the waveform is useful by itself, the dump of the contents of the memory
and the registers at the end of the simulation can tell us what are the result
of the computations done by the CPU.  To generate such dumps, we need to pass
`tbgen` the arguments `dump:registerfile.registers:registers.dump` and
`dump:memdata.data:memory.dump`.

For example, the following command reads the datapath for the single-cycle CPU,
and generates the testbench for it in the file `testbench.v`.

	$ cd cpu-singlecycle
	$ ../tools/tbgen -v incdir=../include \
	                 -v dumplevel=3 \
	                 dump:registerfile.registers:registers.dump \
	                 dump:memdata.data:memory.dump \
	                 datapath.v \
	                 >testbench.v


## SEE ALSO

The AWK Programming Language
by Alfred V. Aho, Brian W. Kernighan, and Peter J. Weinberger,
Addison-Wesley, 1988.
ISBN 0-201-07981-X.

tbgen: Testbench generator in AWK for Verilog modules 
https://github.com/phillbush/tbgen
